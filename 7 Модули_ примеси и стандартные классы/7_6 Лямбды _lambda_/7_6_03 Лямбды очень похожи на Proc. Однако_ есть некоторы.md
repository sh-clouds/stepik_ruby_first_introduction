Лямбды очень похожи на Proc. Однако, есть некоторые важные различия.

1. Первая разница между Proc и лямбда заключается в том, как обрабатываются аргументы. Лямбды проверяют количество аргументов, а Proc - нет. 

Например:

talk = lambda { |x| puts "Hello #{x}" }
talk_proc = Proc.new { |x| puts "Привет, #{x}" }

talk.call "Степик"
# выведет: Привет, Степик

talk_proc.call "Степик"
# выведет: Привет, Степик

                  
Как видите, лямбда и Proc работают одинаково, когда количество переданных в них аргументов было соответствующим.
Однако, если мы попытаемся вызвать их с неправильным количеством аргументов, то:

talk_proc.call
# выведет: Привет

talk.call
# выведет: "Error: wrong number of arguments (given 0, expected 1)"

                  
Как видите, когда лямбда ожидает аргумент, необходимо передать эти аргументы, иначе произойдет ошибка. Однако, в случае с Proc, если аргумент не передан, он автоматически сводится к nil по умолчанию.

2. Второе отличие между лямбда и Proc заключается в том, как обрабатывается оператор return.

Когда лямбда встречает оператор return, она возвращает выполнение в метод, внутри которого она вызывается.
Однако, когда Proc встречает оператор return, он делает возврат из себя и прерывает выполнение метода внутри которого он был вызван.

Понять это может быть несколько сложно, поэтому давайте рассмотрим два примера. Сначала посмотрим на поведение лямбды:

def lambda_test
  lam = lambda { return }
  lam.call
  puts 'Лямбда напечатает!'
end
lambda_test # выведет: Лямбда напечатает!

                  
Мы видим, что лямбда отработала и метод lambda_test продолжил свою работу. Следующий пример показывает аналогичную ситуацию с использованием Proc:

def proc_test
  proc = Proc.new { return }
  proc.call
  puts 'А прок не напечатает :('
end
proc_test # не выведет ничего(

                  
В этом примере видно, что выполнение метода proc_test прекратилось cразу после вызова внутри него блока Proc.